<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[死锁演示]]></title>
    <url>%2F2018%2F04%2F10%2FconcurrenceArtDeadLock%2F</url>
    <content type="text"><![CDATA[死锁 锁是一个非常有用的工具，运用场景非常多，因为它使用起来非常简单，而且易于理解。但同时它也会带来一些困扰，那就是可能会引起死锁。死锁是多线程编程里比较容易碰到的一个问题，尤其是锁嵌套的情况下，极易发生互相请求锁资源而不得的情况，下面给出一个简单的死锁示例。 123456789101112131415161718192021222324252627282930313233343536package basic.demo.concurrence.art.chapter1;public class DeadLockDemo &#123; private static String A = "A"; private static String B = "B"; public static void main(String[] args) &#123; new DeadLockDemo().deadLock(); &#125; @SuppressWarnings("static-access") private void deadLock()&#123; new Thread(() -&gt; &#123; synchronized(A)&#123; try&#123; Thread.currentThread().sleep(2000); &#125;catch(InterruptedException e)&#123; e.printStackTrace(); &#125; synchronized(B)&#123; System.out.println("1"); &#125; &#125; &#125;).start(); new Thread(() -&gt; &#123; synchronized(B)&#123; synchronized(A)&#123; System.out.println("2"); &#125; &#125; &#125;).start(); &#125;&#125; 运行程序后，console没有任何输出，死锁发生。 检测方法： 在cmd窗口中输入jps指令，会列出当前所有的Java进程 C:\Users\chens&gt;jps1744 org.eclipse.equinox.launcher_1.3.100.v20150511-1540.jar11460 DeadLockDemo3276 Jps 使用jstack &lt;进程编号&gt;输出当前Java进程的状态，如下图所示： 如何避免死锁： 避免一个线程同时获取过多的锁 避免一个线程在锁内同时占有过多资源 尽量使用lock.tryLock(timeout)替代使用内部锁机制 对于数据库锁，在一个连接内包含加锁和解锁动作，避免出现解锁失败的情况 参考资料： https://blog.csdn.net/zlbflying/article/details/51163473 《Java并发编程的艺术》]]></content>
      <categories>
        <category>并发</category>
        <category>并发编程艺术笔记</category>
      </categories>
      <tags>
        <tag>deadLock</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Netty权威指南笔记(一)]]></title>
    <url>%2F2018%2F04%2F09%2FNettyGuide1%2F</url>
    <content type="text"><![CDATA[chapter1 1.UNIX提供的5中I/O模型 (1) 阻塞I/O模型：最常用的I/O模型，缺省情形下，所有的文件操作都是阻塞的。我们以套接字接口为例来讲解此模型：在进程空间中调用recvfrom, 其系统调用直到数据包到达且被复制到应用缓冲区中或者发生错误时才返回，在此期间一直会等待，进程在从调用recvfrom开始到它返回的整段时间内都是被阻塞的，因此被称为阻塞I/O模型，如图1-1所示。 (2)非阻塞I/O模型：recvfrom从应用层到内核的时候，如果该缓冲区没有数据的话，就直接返回一个EWOULDBLOCK错误，一般都对非阻塞I/O模型进行轮询检查这个状态，看内核是不是有数据到来。如图1-2所示。 (3)I/O复用模型：Linux提供select/poll，进程通过将一个或多个fd传递给select或poll系统调用，阻塞在select操作上，这样select/poll可以帮助我们侦测多个fd是否处于就绪状态。select/poll是顺序扫描fd是否就绪，而且支持的fd数量有限，因此它的使用受到了一些制约，Linux还提供了一个epoll系统调用，epoll使用基于事件驱动方式代替顺序扫描，因此性能更高。当有fd就绪时，立即回调函数rollback。如图1-3所示。 (4)信号驱动I/O模型：首先开启套接口信号驱动I/O功能，并通过系统调用sigaction执行一个信号处理函数（此系统调用立即返回，进程继续工作，它是非阻塞的）。当数据准备就绪时，就为该进程生成一个SIGIO信号，通过信号回调通知应用程序调用recvfrom来读取数据，并通知主函数处理数据。如图1-4所示。 (5)异步I/O：告知内核启动某个操作，并让内核在整个操作完成后（包括将数据从内核复制到用户自己的缓冲区）通知我们。这种模型与信号驱动模型的主要区别是：信号驱动I/O由内核通知我们何时可以开始一个I/O操作；异步I/O模型由内核通知我们I/O操作何时已经完成。如图1-5所示。 chapter2 网络编程的基本模型是Client/Server模型，也就是两个进程之间进行相互通信，其中服务端提供位置信息（绑定的IP地址和监听端口），客户端通过连接操作向服务端监听的地址发起连接请求，通过三次握手建立连接，如果建立连接成功，双方就可以通过网络套接字（Socket）进行通信。 1.BIO编程 BIO的服务端通信模型如图2-1所示：采用BIO通信模型的服务器，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端的连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成之后，通过输出流返回应答给客户端，线程销毁。这就是典型的一请求一应答通信模型。代码 BIO的主要问题：每当有一个新的客户端请求接入时，服务端必须创建一个新的线程处理新的接入的客户端链路，一个线程只能处理一个客户端连接。在高性能服务器应用领域，往往需要成千上万个客户端的并发连接，这种模型显然无法满足高性能、高并发接入的场景。 BIO的主要问题：每当有一个新的客户端请求接入时，服务端必须创建一个新的线程处理新的接入的客户端链路，一个线程只能处理一个客户端连接。在高性能服务器应用领域，往往需要成千上万个客户端的并发连接，这种模型显然无法满足高性能、高并发接入的场景。 2.伪异步I/O编程 为了解决同步阻塞I/O面临的一个链路需要一个线程处理的问题，有人对它的线程模型进行了优化，后端通过一个线程池来处理多个客户端的请求接入，形成客户端个数M:线程池最大线程数N的比例关系，其中M可以远远大于N，通过线程池可以灵活的调配线程资源，设置线程的最大值，防止由于海量并发接入导致线程耗尽。 采用线程池和任务队列可以实现一种叫做伪异步的I/O通信框架，它的模型如图2-5所示。当有新的客户端接入时，将客户端的Socket封装成一个Task(该任务实现了java.lang.Runnable接口)投递到后端的线程池中进行处理，JDK的线程池维护一个消息队列和N个活跃线程对消息队列中的任务进行处理。由于线程池可以设置消息队列的大小和最大线程数，因此，它的资源占用是可控的，无论多少个客户端并发访问，都不会导致资源的耗尽和宕机。代码 伪异步I/O实际上仅仅只是对之前BIO的线程模型的一个简单优化，它无法从根本上解决同步I/O导致的通信线程阻塞问题。 3.NIO编程 名称（New I/O or Non-block I/O） 与Socket类和ServerSocket类相对应，NIO也提供了SocketChannel和ServerSocketChannel两种不同的套接字通道实现。这两种新增的通道都支持阻塞和非阻塞两种模式。一般来说，低负载、低并发的应用程序可以选择同步阻塞I/O以降低编程复杂度，但对于高负载、高并发的网络应用，需要使用NIO的非阻塞模式进行开发。 1.NIO类库简介 (1)缓冲区Buffer ByteBuffer：字节缓冲区 CharBuffer：字符缓冲区 ShortBuffer：短整型缓冲区 IntBuffer：整型缓冲区 LongBuffer：长整型缓冲区 FloatBuffer：浮点型缓冲区 DoubleBuffer：双精度浮点型缓冲区 (2)通道channel FileChannel DatagramChannel SocketChannel ServerSocketChannel (3)多路复用器Selector 基于epoll()代替传统的select实现。详情分析 2.NIO服务端介绍 (1)NIO服务端序列图 NIO服务端序列图如图2-10所示。 (2)NIO服务端的主要创建过程 步骤一：打开ServerSocketChannel, 用于监听客户端的连接，它是所有客户端连接的父管道，代码示例如下： 1ServerSocketChannel acceptorSvr = ServerSocketChannel.open(); 步骤二：绑定监听端口，设定连接为非阻塞模式： 12acceptorSvr.socket().bind(new InetSocketAddress(InetAddress.getByName("IP"), port));acceptorSvr.configureBlocking(false); 步骤三：创建Reactor线程（Reactor模式），创建多路复用器并启动线程： 12Selector selector = Selector.open();New Thread(new ReactorTask()).start(); 步骤四：将ServerSocketChannel注册到Reactor线程的多路复用器Selector上，监听ACCEPT事件： 1SelectionKey key = acceptorSvr.register(selector, SelectionKey.OP_ACCEPT, ioHandler); 步骤五：多路复用器在线程run()方法的无限循环体内轮询准备就绪的Key: 1234567int num = selector.select();Set selectedKeys = selector.selectedKeys();Iterator it = selectedKeys.iterator();while(it.hasNext())&#123; SelectionKey key = (SelectionKey)it.next(); //... deal with I/O event ...&#125; 步骤六：多路复用器监听到有新的客户端接入，处理新的接入请求，完成三次TCP握手，建立物理链路： 1SocketChannel socketChannel = acceptorSvr.accept(); 步骤七：设置客户端链路为非阻塞模式： 123channel.configureBlocking(false);channel.socket().setReuseAddress(true);... 步骤八：将新接入的客户端连接注册到Reactor线程的多路复用器上，监听读操作，用来读取客户端发送的网络消息： 1SelectionKey key = socketChannel.register(selector, SelectionKey.OP_READ, ioHandler); 步骤九：异步读取客户端请求消息到缓冲区： 1int readNumber = socketChannel.read(receivedBuffer); 步骤十：对ByteBuffer进行编解码，如果有半包消息指针reset，继续读取后续的报文，将解码成功的消息封装成Task, 投递到业务线程池中，进行业务逻辑编排： 123456789101112131415161718192021Object message = null;while(buffer.hasRemain())&#123; byteBuffer.mark(); Object message = decode(byteBuffer); if(message == null)&#123; byteBuffer.reset(); break; &#125; messageList.add(message);&#125;if(!byteBuffer.hasRemain())&#123; byteBuffer.clear();&#125;else&#123; byteBuffer.compact();&#125;if(messageList != null &amp;&amp; !messageList.isEmpty())&#123; for(Object messageE : messageList)&#123; hadlerTask(messageE); //业务逻辑 &#125;&#125; 步骤十一：将POJO对象encode成ByteBuffer, 调用SocketChannel的异步write()接口，将消息异步发送给客户端： 1socketChannel.write(buffer); 完整代码 3.NIO客户端介绍 (1)NIO客户端创建序列图 NIO客户端创建序列图如图2-11所示。 (2)NIO客户端的主要创建过程 步骤一：打开SocketChannel, 绑定客户端本地地址（可选，默认系统会随机分配一个可用的本地地址）： 1SocketChannel clientChannel = SocketChannel.open(); 步骤二：设置SocketChannel为非阻塞模式，同时设置客户端连接的TCP参数： 1234clientChannel.configureBlocking(false);socket.setReuseAddress(true);socket.setReceiveBufferSize(BUFFER_SIZE);socket.setSendBufferSize(BUFFER_SIZE); 步骤三：异步连接服务端： 1boolean connected = clientChannel.connect(new InetSocketAddress("IP", port)); 步骤四：判断是否连接成功，如果连接成功，则直接注册读状态位到多路复用器中，如果当前没有连接成功（异步连接，返回false，说明客户端已经发送sync包，服务端没有返回ack包，物理链路还没有 建立）： 12345if(connected)&#123; clientChannel.register(selector, SelectionKey.OP_READ, ioHandler);&#125;else&#123; clientChannel.register(selector, SelectionKey.OP_CONNECT, ioHandler);&#125; 步骤五：向Reactor线程的多路复用器注册OP_CONNECT状态位，监听服务器端的ACK应答: 1clientChannel.register(selector, SelectionKey.OP_CONNECT, ioHandler); 步骤六：创建Reactor线程（Reactor模式），创建多路复用器并启动线程： 12Selector selector = Selector.open();New Thread(new ReactorTask()).start(); 步骤七：多路复用器在线程run()方法的无限循环体内轮询准备就绪的Key: 1234567int num = selector.select();Set selectedKeys = selector.selectedKeys();Iterator it = selectedKeys.iterator();while(it.hasNext())&#123; SelectionKey key = (SelectionKey)it.next(); //... deal with I/O event ...&#125; 步骤八：接收connect事件进行处理： 123if(key.isConnectable())&#123; //handleConnect();&#125; 步骤九：判断连接结果，如果连接成功，注册读事件到多路复用器： 123if(channel.finishConnect())&#123; registerRead();&#125; 步骤十：注册读事件到多路复用器： 1clientChannel.register(selector, SelectionKey.OP_READ, ioHandler); 步骤十一：异步读取客户端请求消息到缓冲区： 1int readNumber = socketChannel.read(receivedBuffer); 步骤十二：对ByteBuffer进行编解码，如果有半包消息指针reset，继续读取后续的报文，将解码成功的消息封装成Task, 投递到业务线程池中，进行业务逻辑编排： 123456789101112131415161718192021Object message = null;while(buffer.hasRemain())&#123; byteBuffer.mark(); Object message = decode(byteBuffer); if(message == null)&#123; byteBuffer.reset(); break; &#125; messageList.add(message);&#125;if(!byteBuffer.hasRemain())&#123; byteBuffer.clear();&#125;else&#123; byteBuffer.compact();&#125;if(messageList != null &amp;&amp; !messageList.isEmpty())&#123; for(Object messageE : messageList)&#123; hadlerTask(messageE); //业务逻辑 &#125;&#125; 步骤十三：将POJO对象encode成ByteBuffer, 调用SocketChannel的异步write()接口，将消息异步发送给客户端： 1socketChannel.write(buffer); 完整代码 4.NIO编程的优点 (1)客户端发起的连接操作是异步的，可以通过多路复用器注册OP_CONNECT等待后续结果，不需要像之前的客户端那样被同步阻塞。 (2)SocketChannel的读写操作都是异步的，如果没有可读写的数据它不会同步等待，直接返回，这样I/O通信线程就可以处理其它的链路，不需要同步等待这个链路可用。 (3)线程模型的优化：由于JDK的Selector在Linux等主流操作系统上通过epoll实现，它没有句柄数的限制（只受限于操作系统最大句柄数或者对单个进程的句柄限制），这意味着一个Selector线程可以同时处理成千上万个客户端连接，而且性能不会随着客户端的增加而线性下降，因此，它非常适合做高性能、高负载的网络服务器。]]></content>
      <categories>
        <category>Java基础</category>
        <category>NIO</category>
      </categories>
      <tags>
        <tag>NIO</tag>
        <tag>Netty</tag>
        <tag>Java I/O]</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微软100题-#11题-求二叉树中节点的最大距离]]></title>
    <url>%2F2018%2F03%2F11%2F%E5%BE%AE%E8%BD%AF100%E9%A2%98-11%E9%A2%98-%E6%B1%82%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E8%8A%82%E7%82%B9%E7%9A%84%E6%9C%80%E5%A4%A7%E8%B7%9D%E7%A6%BB%2F</url>
    <content type="text"><![CDATA[原题： 第11题（树）求二叉树中节点的最大距离… 如果我们把二叉树看成一个图，父子节点之间的连线看成是双向的，我们姑且定义”距离”为两节点之间边的个数。写一个程序，求一棵二叉树中相距最远的两个节点之间的距离。 看到这个题目，立马想到前不久刷LeetCode的时候碰到过的一个题目（#543: Diameter of Binary Tree），求二叉树的直径。这里只不过用另外一种方式表述了相同的意思。 《编程之美》一书以及网上一位叫Milo的大牛给出了题目的分析: 《编程之美: 求二叉树中节点的最大距离》的另一个解法： 总结起来，求二叉树中节点的最大距离需要考虑两种情况： 情况A: 路径经过左子树的最深节点，通过根节点，再到右子树的最深节点； 情况B: 路径不穿过根节点，而是左子树或者右子树的最大距离，取其大者。 具体分析讨论以及解题代码见上面的链接，下面要贴出的代码是做LeetCode第543题时网上参考的两种写法，这两种写法逻辑清晰，一目了然。 方法一： 这其实是一道关于二叉树的问题， 一般此类问题都是通过采用递归的思路进行处理，我们可以这样想，其实我们需要求解的所谓的D(diameter)实际上可以这么表示： ​ D=max(Dleft_child, Dright_child, maxDeepleft+maxDeepright) 也就是说，为了求解这个问题，我们可以将他拆解为3个部分，分别为只包含左子树的子问题Dleft_child 和只包含右子树的子问题 Dright_child，以及经过当前根节点的问题。 123456789101112131415161718192021222324252627282930313233343536373839404142class TreeNode&#123; int val; TreeNode left; TreeNode right; public TreeNode(int x)&#123; val = x; &#125;&#125;public int diameterOfBinaryTree(TreeNode node)&#123; if(null == node)&#123; return 0; &#125; int leftDiameter = 0, rightDiameter = 0, leftDepth = 0, rightDepth = 0; if(null != node.left)&#123; leftDepth = getDepth(node.left); leftDiameter = diameterOfBinaryTree(node.left); &#125; if(null != node.right)&#123; rightDepth = getDepth(node.right); rightDiameter = diameterOfBinaryTree(node.right); &#125; return Math.max(Math.max(leftDiameter, rightDiameter), leftDepth + rightDepth);&#125;public int getDepth(TreeNode node)&#123; if(null == node)&#123; return 0; &#125; int leftDepth = 0, rightDepth = 0; if(null != node.left)&#123; leftDepth = getDepth(node.left); &#125; if(null != node.right)&#123; rightDepth = getDepth(node.right); &#125; return Math.max(leftDepth, rightDepth) + 1;&#125; 方法二： 实际上对于每一个节点我们都可以计算以他为根节点的diameter的长度，那么我们只需要在这个过程中，挑选得到长度最长的那个diameter就可以了 。 123456789101112131415161718int max = 0;public int diameterOfBinaryTree2(TreeNode node)&#123; &#125;public int maxDepth2(TreeNode node)&#123; if(null == node)&#123; return 0; &#125; int leftDepth = maxDepth2(node.left); int rightDepth = maxDepth2(node.right); max = Math.max(max, leftDepth + rightDepth); return Math.max(leftDepth, rightDepth) + 1;&#125; 参考： https://www.cnblogs.com/miloyip/archive/2010/02/25/1673114.html http://blog.csdn.net/zhyh1435589631/article/details/65939602]]></content>
      <categories>
        <category>算法</category>
        <category>微软100题</category>
      </categories>
      <tags>
        <tag>算法</tag>
        <tag>微软100题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java多线程之内存可见性]]></title>
    <url>%2F2018%2F02%2F27%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[主要知识点 什么是内存可见性 Java内存模型（JMM） 实现可见性的方式：synchronized和volatile synchronized和volatile实现内存可见性的原理 synchronized实现可见性 指令重排序 as-if-serial语义 volatile实现可见性 volatile能够保证可见性 volatile不能保证原子性 volatile使用注意事项 synchronized和volatile比较 volatile比synchronized更轻量级 volatile没有synchronized使用的广泛 首先介绍一下相关的一些概念： 可见性：一个线程对共享变量值的修改，能够及时地被其它线程看到。 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。 Java内存模型（JMM）：Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。 所有的变量都存储在主内存中 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝） 两条重要规则： 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写； 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。 共享变量可见性实现的原理 线程1对共享变量的修改要想被线程2及时看到，必须要经过如下两个步骤： 把工作内存1中更新过的共享变量刷新到主内存中 将主内存中最新的共享变量的值更新到工作内存2中 可见性的实现方式 Java语言层面支持的可见性实现方式： synchronized volatile 1.synchronized实现可见性 synchronized能够实现： 原子性（同步） 可见性 JMM关于synchronized的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存中 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量的时候需要从主内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁） 上面两点确保了线程解锁前对共享变量的修改在下次加锁时对其他线程可见 总结一下synchronized线程执行互斥代码的过程： 获得互斥锁 清空工作内存 从主内存拷贝变量的最新副本到工作内存 执行代码 将更改后的共享变量的值刷新到主内存 释放互斥锁 重排序：代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化 编译器优化的重排序（编译器优化） 指令级并行重排序（处理器优化） 内存系统的重排序（处理器优化） as-if-serial: 无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致（Java编译器、运行时和处理器都会保证Java在单线程下遵循as-if-serial语义） 如下面的代码： 123int num = 1; // line 1int num = 2; // line 2int sum = num1 + num2; // line 3 对于单线程：第1、2行的顺序可以重排，但第3行不能 重排序不会给单线程带来内存可见性问题，但是在多线程中程序交错执行时，重排序可能会造成内存可见性问题。 下面分析一段代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class SynchronizedDemo &#123; //共享变量 private boolean ready = false; private int result = 0; private int number = 1; //write public void write()&#123; ready = true; number = 2; &#125; //read public void read()&#123; if(ready)&#123; result = number * 3; &#125; System.out.println("result的值为：" + result); &#125; //内部线程类 private class ReadWriteThread extends Thread&#123; //根据构造方法中传入的flag参数，确定线程执行读操作还是写操作 private boolean flag; public ReadWriteThread(boolean flag)&#123; this.flag = flag; &#125; @Override public void run()&#123; if(flag)&#123; //构造方法传入true,执行写操作 write(); &#125;else&#123; //构造方法传入false,执行读操作 read(); &#125; &#125; &#125; public static void main(String[] args) &#123; SynchronizedDemo synDemo = new SynchronizedDemo(); //启动线程执行写操作 synDemo.new ReadWriteThread(true).start(); //启动线程执行读操作 synDemo.new ReadWriteThread(false).start(); &#125;&#125; 运行main方法后会启动两个线程，分别为写操作和读操作。如果上面的代码中，先执行完写操作线程，再执行读操作线程，那么最后result的结果应该为6. 但是在实际运行过程中，可能会有不同的结果，我们将上面代码中的关键代码摘出来进行分析： 123456789101112131415161718//共享变量private boolean ready = false;private int result = 0;private int number = 1;//writepublic void write()&#123; ready = true; //1.1 number = 2; //1.2&#125;//readpublic void read()&#123; if(ready)&#123; //2.1 result = number * 3; //2.2 &#125; System.out.println("result的值为：" + result);&#125; 其中的一种可能执行顺序为：1.1—&gt;2.1—&gt;2.2—&gt;1.2, 那么result的值应该为3. 另一种可能的执行顺序：1.2—&gt;2.1—&gt;2.2—&gt;1.1, 在这种顺序中代码进行了重排序，在执行读操作时，ready仍然为false，所以最后result的值应该为0. 甚至，2.1和2.2也有可能进行重排序，虽然if是判断条件，但是2.1和2.2没有数据依赖关系，所以可以重排序，它们重排序后的代码实际为： 1234int mid = number*3;if(ready)&#123; result = mid;&#125; 根据上面的代码分析，我们得出导致共享变量在线程间不可见的原因： 线程的交叉执行 重排序结合线程交叉执行 共享变量更新后的值没有在工作内存与主内存间及时更新 安全的代码： 12345678910111213//writepublic synchronized void write()&#123; ready = true; number = 2;&#125;//readpublic synchronized void read()&#123; if(ready)&#123; result = number * 3; &#125; System.out.println("result的值为：" + result);&#125; 不可见的原因： synchronized解决方案 1.线程的交叉执行 —&gt; 原子性 2.重排序结合线程交叉执行 —&gt; 原子性 3.共享变量未及时更新 —&gt; 可见性 此外：加上synchronized之后，也有可能先执行读操作线程，然后再执行写操作线程，为了保证result为6，可以在执行读操作之前添加一个sleep语句。 2.volatile实现可见性 volatile关键字： 能够保证volatile变量的可见性 不能保证volatile变量复合操作的原子性 volatile如何实现内存可见性： 深入来说：通过加入内存屏障和禁止重排序优化来实现可见性。 对volatile变量执行写操作时，会在写操作后加入一条store屏障指令（把缓存强制刷入主内存） 对volatile变量执行读操作时，会在读操作前加入一条load屏障指令 通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中读取该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。 线程写volatile变量的过程： 改变线程工作内存中volatile变量副本的值 将改变后的副本的值从工作内存刷新到主内存 线程读volatile变量的过程： 从主内存中读取volatile变量的最新值到线程的工作内存中 从工作内存中读取volatile变量的副本 volatile不能保证volatile变量复合操作的原子性： 12private int number = 0;number++; //不是原子操作 1.读取number的值 2.将number的值加1 3.写入最新的number的值 如果加上synchronized： 123synchronized(this)&#123; number++;&#125; 因为要执行完synchronized里面的语句，才释放线程锁，所以这里保证了number++的原子性。 而如果是private volatile int number = 0, 虽然number变为volatile变量，但仍然无法保证原子性。 下面分析一段代码： 12345678910111213141516171819202122232425262728293031323334353637383940public class VolatileDemo &#123; private volatile int number = 0; public int getNumber()&#123; return this.number; &#125; public void increase()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.number++; &#125; public static void main(String[] args) &#123; final VolatileDemo volDemo = new VolatileDemo(); for(int i = 0; i &lt; 500; i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; volDemo.increase(); &#125; &#125;).start(); &#125; //如果还有子线程在运行，主线程就让出CPU资源 //直到所有的子线程都运行完了，主线程再继续往下执行 while(Thread.activeCount() &gt; 1)&#123; Thread.yield(); &#125; System.out.println("number: " + volDemo.getNumber()); &#125;&#125; number初始值为0，执行500次加1操作（由于number为volatile变量，每次加1后最新的值能及时刷入主内存），这样最终的结果应该为500. 但多次运行发现结果不一定为500，很多次执行结果少于500（sleep的引入增加了少于500的概率），这是为什么呢？ 程序分析： number=5 1.线程A读取number的值 2.线程B读取number的值 3.线程B执行加1操作 4.线程B写入最新的number的值 这时候： 主内存：number=6 线程B的工作内存：number=6 而线程A的工作内存：number=5 5.线程A执行加1操作 6.线程A写入最新的number值 结果：两次number++，只增加了1 由于number++不是原子操作，导致了number的最终结果多次少于500. 解决方案： 保证number自增操作的原子性： 使用synchronized关键字 使用ReentrantLock（java.util.concurrent.locks包下） 使用AtomicInteger(java.util.concurrent.atomic包下) 1.使用synchronized关键字 private volatile int number = 0; 中去掉volatile关键字 1234567891011public void increase()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; synchronized(this)&#123; //synchronized放在此处粒度更小，避免等待sleep太长时间 this.number++; &#125;&#125; 2.使用ReentrantLock 首先需要声明可重入锁： private Lock lock = new ReentrantLock(); 然后，在执行number++之前先获取锁，再进行自增操作 123456lock.lock();try&#123; this.number++;&#125;finally&#123; lock.unlock();&#125; volatile适用场合 要在多线程中安全地使用volatile变量，必须同时满足： 1.对变量的写入操作不依赖其当前值 不满足：number++、count = count*5等 满足：boolean变量、记录温度变化的变量等 2.该变量没有包含在具有其他变量的不变式中 不满足：不变式low&lt;up synchronized和volatile比较 volatile不需要加锁，比synchronized更轻量级，不会阻塞线程； 从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁。 synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。 问题 1.即使没有保证可见性措施，很多时候共享变量依然能够在主内存和工作内存间得到及时的更新？ 答：一般只有在短时间内高并发的情况下才会出现变量得不得及时更新的情况，因为CPU在执行时会很快地刷新缓存，所以一般情况下很难看到这种问题。 2.对64位(long, double)变量的读写可能不是原子操作： 原因：Java内存模型允许JVM将没有被volatile修饰的64位数据类型的读写操作划分为两次32位的读写操作来进行。 导致问题：有可能出现读取到“半个变量”的情况。 解决方法：加volatile关键字。 参考：https://www.imooc.com/video/6812]]></content>
      <categories>
        <category>Java内存</category>
        <category>Java内存模型</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存可见性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First blog]]></title>
    <url>%2F2017%2F12%2F22%2FFirst-blog%2F</url>
    <content type="text"><![CDATA[Hello Blog well done!]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
