<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java多线程之内存可见性]]></title>
    <url>%2F2018%2F02%2F27%2FJava%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B9%8B%E5%86%85%E5%AD%98%E5%8F%AF%E8%A7%81%E6%80%A7%2F</url>
    <content type="text"><![CDATA[主要知识点 什么是内存可见性 Java内存模型（JMM） 实现可见性的方式：synchronized和volatile synchronized和volatile实现内存可见性的原理 synchronized实现可见性 指令重排序 as-if-serial语义 volatile实现可见性 volatile能够保证可见性 volatile不能保证原子性 volatile使用注意事项 synchronized和volatile比较 volatile比synchronized更轻量级 volatile没有synchronized使用的广泛 首先介绍一下相关的一些概念： 可见性：一个线程对共享变量值的修改，能够及时地被其它线程看到。 共享变量：如果一个变量在多个线程的工作内存中都存在副本，那么这个变量就是这几个线程的共享变量。 Java内存模型（JMM）：Java内存模型（Java Memory Model）描述了Java程序中各种变量（线程共享变量）的访问规则，以及在JVM中将变量存储到内存和从内存中读取变量这样的底层细节。 所有的变量都存储在主内存中 每个线程都有自己独立的工作内存，里面保存该线程使用到的变量的副本（主内存中该变量的一份拷贝） 两条重要规则： 线程对共享变量的所有操作都必须在自己的工作内存中进行，不能直接从主内存中读写； 不同线程之间无法直接访问其他线程工作内存中的变量，线程间变量值的传递需要通过主内存来完成。 共享变量可见性实现的原理 线程1对共享变量的修改要想被线程2及时看到，必须要经过如下两个步骤： 把工作内存1中更新过的共享变量刷新到主内存中 将主内存中最新的共享变量的值更新到工作内存2中 可见性的实现方式 Java语言层面支持的可见性实现方式： synchronized volatile 1.synchronized实现可见性 synchronized能够实现： 原子性（同步） 可见性 JMM关于synchronized的两条规定： 线程解锁前，必须把共享变量的最新值刷新到主内存中 线程加锁时，将清空工作内存中共享变量的值，从而使用共享变量的时候需要从主内存中重新读取最新的值（注意：加锁与解锁需要是同一把锁） 上面两点确保了线程解锁前对共享变量的修改在下次加锁时对其他线程可见 总结一下synchronized线程执行互斥代码的过程： 获得互斥锁 清空工作内存 从主内存拷贝变量的最新副本到工作内存 执行代码 将更改后的共享变量的值刷新到主内存 释放互斥锁 重排序：代码书写的顺序与实际执行的顺序不同，指令重排序是编译器或处理器为了提高程序性能而做的优化 编译器优化的重排序（编译器优化） 指令级并行重排序（处理器优化） 内存系统的重排序（处理器优化） as-if-serial: 无论如何重排序，程序执行的结果应该与代码顺序执行的结果一致（Java编译器、运行时和处理器都会保证Java在单线程下遵循as-if-serial语义） 如下面的代码： 123int num = 1; // line 1int num = 2; // line 2int sum = num1 + num2; // line 3 对于单线程：第1、2行的顺序可以重排，但第3行不能 重排序不会给单线程带来内存可见性问题，但是在多线程中程序交错执行时，重排序可能会造成内存可见性问题。 下面分析一段代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849public class SynchronizedDemo &#123; //共享变量 private boolean ready = false; private int result = 0; private int number = 1; //write public void write()&#123; ready = true; number = 2; &#125; //read public void read()&#123; if(ready)&#123; result = number * 3; &#125; System.out.println("result的值为：" + result); &#125; //内部线程类 private class ReadWriteThread extends Thread&#123; //根据构造方法中传入的flag参数，确定线程执行读操作还是写操作 private boolean flag; public ReadWriteThread(boolean flag)&#123; this.flag = flag; &#125; @Override public void run()&#123; if(flag)&#123; //构造方法传入true,执行写操作 write(); &#125;else&#123; //构造方法传入false,执行读操作 read(); &#125; &#125; &#125; public static void main(String[] args) &#123; SynchronizedDemo synDemo = new SynchronizedDemo(); //启动线程执行写操作 synDemo.new ReadWriteThread(true).start(); //启动线程执行读操作 synDemo.new ReadWriteThread(false).start(); &#125;&#125; 运行main方法后会启动两个线程，分别为写操作和读操作。如果上面的代码中，先执行完写操作线程，再执行读操作线程，那么最后result的结果应该为6. 但是在实际运行过程中，可能会有不同的结果，我们将上面代码中的关键代码摘出来进行分析： 123456789101112131415161718//共享变量private boolean ready = false;private int result = 0;private int number = 1;//writepublic void write()&#123; ready = true; //1.1 number = 2; //1.2&#125;//readpublic void read()&#123; if(ready)&#123; //2.1 result = number * 3; //2.2 &#125; System.out.println("result的值为：" + result);&#125; 其中的一种可能执行顺序为：1.1—&gt;2.1—&gt;2.2—&gt;1.2, 那么result的值应该为3. 另一种可能的执行顺序：1.2—&gt;2.1—&gt;2.2—&gt;1.1, 在这种顺序中代码进行了重排序，在执行读操作时，ready仍然为false，所以最后result的值应该为0. 甚至，2.1和2.2也有可能进行重排序，虽然if是判断条件，但是2.1和2.2没有数据依赖关系，所以可以重排序，它们重排序后的代码实际为： 1234int mid = number*3;if(ready)&#123; result = mid;&#125; 根据上面的代码分析，我们得出导致共享变量在线程间不可见的原因： 线程的交叉执行 重排序结合线程交叉执行 共享变量更新后的值没有在工作内存与主内存间及时更新 安全的代码： 12345678910111213//writepublic synchronized void write()&#123; ready = true; number = 2;&#125;//readpublic synchronized void read()&#123; if(ready)&#123; result = number * 3; &#125; System.out.println("result的值为：" + result);&#125; 不可见的原因： synchronized解决方案 1.线程的交叉执行 —&gt; 原子性 2.重排序结合线程交叉执行 —&gt; 原子性 3.共享变量未及时更新 —&gt; 可见性 此外：加上synchronized之后，也有可能先执行读操作线程，然后再执行写操作线程，为了保证result为6，可以在执行读操作之前添加一个sleep语句。 2.volatile实现可见性 volatile关键字： 能够保证volatile变量的可见性 不能保证volatile变量复合操作的原子性 volatile如何实现内存可见性： 深入来说：通过加入内存屏障和禁止重排序优化来实现可见性。 对volatile变量执行写操作时，会在写操作后加入一条store屏障指令（把缓存强制刷入主内存） 对volatile变量执行读操作时，会在读操作前加入一条load屏障指令 通俗地讲：volatile变量在每次被线程访问时，都强迫从主内存中读取该变量的值，而当该变量发生变化时，又会强迫线程将最新的值刷新到主内存。这样任何时刻，不同的线程总能看到该变量的最新值。 线程写volatile变量的过程： 改变线程工作内存中volatile变量副本的值 将改变后的副本的值从工作内存刷新到主内存 线程读volatile变量的过程： 从主内存中读取volatile变量的最新值到线程的工作内存中 从工作内存中读取volatile变量的副本 volatile不能保证volatile变量复合操作的原子性： 12private int number = 0;number++; //不是原子操作 1.读取number的值 2.将number的值加1 3.写入最新的number的值 如果加上synchronized： 123synchronized(this)&#123; number++;&#125; 因为要执行完synchronized里面的语句，才释放线程锁，所以这里保证了number++的原子性。 而如果是private volatile int number = 0, 虽然number变为volatile变量，但仍然无法保证原子性。 下面分析一段代码： 12345678910111213141516171819202122232425262728293031323334353637383940public class VolatileDemo &#123; private volatile int number = 0; public int getNumber()&#123; return this.number; &#125; public void increase()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; this.number++; &#125; public static void main(String[] args) &#123; final VolatileDemo volDemo = new VolatileDemo(); for(int i = 0; i &lt; 500; i++)&#123; new Thread(new Runnable()&#123; @Override public void run() &#123; volDemo.increase(); &#125; &#125;).start(); &#125; //如果还有子线程在运行，主线程就让出CPU资源 //直到所有的子线程都运行完了，主线程再继续往下执行 while(Thread.activeCount() &gt; 1)&#123; Thread.yield(); &#125; System.out.println("number: " + volDemo.getNumber()); &#125;&#125; number初始值为0，执行500次加1操作（由于number为volatile变量，每次加1后最新的值能及时刷入主内存），这样最终的结果应该为500. 但多次运行发现结果不一定为500，很多次执行结果少于500（sleep的引入增加了少于500的概率），这是为什么呢？ 程序分析： number=5 1.线程A读取number的值 2.线程B读取number的值 3.线程B执行加1操作 4.线程B写入最新的number的值 这时候： 主内存：number=6 线程B的工作内存：number=6 而线程A的工作内存：number=5 5.线程A执行加1操作 6.线程A写入最新的number值 结果：两次number++，只增加了1 由于number++不是原子操作，导致了number的最终结果多次少于500. 解决方案： 保证number自增操作的原子性： 使用synchronized关键字 使用ReentrantLock（java.util.concurrent.locks包下） 使用AtomicInteger(java.util.concurrent.atomic包下) 1.使用synchronized关键字 private volatile int number = 0; 中去掉volatile关键字 1234567891011public void increase()&#123; try &#123; Thread.sleep(100); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; synchronized(this)&#123; //synchronized放在此处粒度更小，避免等待sleep太长时间 this.number++; &#125;&#125; 2.使用ReentrantLock 首先需要声明可重入锁： private Lock lock = new ReentrantLock(); 然后，在执行number++之前先获取锁，再进行自增操作 123456lock.lock();try&#123; this.number++;&#125;finally&#123; lock.unlock();&#125; volatile适用场合 要在多线程中安全地使用volatile变量，必须同时满足： 1.对变量的写入操作不依赖其当前值 不满足：number++、count = count*5等 满足：boolean变量、记录温度变化的变量等 2.该变量没有包含在具有其他变量的不变式中 不满足：不变式low&lt;up synchronized和volatile比较 volatile不需要加锁，比synchronized更轻量级，不会阻塞线程； 从内存可见性角度讲，volatile读相当于加锁，volatile写相当于解锁。 synchronized既能保证可见性，又能保证原子性，而volatile只能保证可见性，无法保证原子性。 问题 1.即使没有保证可见性措施，很多时候共享变量依然能够在主内存和工作内存间得到及时的更新？ 答：一般只有在短时间内高并发的情况下才会出现变量得不得及时更新的情况，因为CPU在执行时会很快地刷新缓存，所以一般情况下很难看到这种问题。 2.对64位(long, double)变量的读写可能不是原子操作： 原因：Java内存模型允许JVM将没有被volatile修饰的64位数据类型的读写操作划分为两次32位的读写操作来进行。 导致问题：有可能出现读取到“半个变量”的情况。 解决方法：加volatile关键字。 参考：https://www.imooc.com/video/6812]]></content>
      <categories>
        <category>Java内存</category>
        <category>Java内存模型</category>
      </categories>
      <tags>
        <tag>JVM</tag>
        <tag>内存可见性</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[First blog]]></title>
    <url>%2F2017%2F12%2F22%2FFirst-blog%2F</url>
    <content type="text"><![CDATA[Hello Blog well done!]]></content>
      <categories>
        <category>Life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2017%2F12%2F22%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
